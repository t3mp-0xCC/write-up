# babyecho  
```https://github.com/ctfs/write-ups-2015/tree/master/defcon-qualifier-ctf-2015/babys-first/babyecho```  
## 概要  
13byteだけ読み取って標準出力に吐いてくれる。  
FSBがあってスタックが実行可能。  
## 解法  
シェルコードを送るにしても13byteは無理があるので、まずは13byteの制限を無くす事を考える。  
バイナリをghidraで逆アセンブルして13byteの制限に関連する部分を抜き出すと以下の通り。  
```c
int val = 0xd;
int buf_size;

do {
	val = 0x3ff;
	if (val < 0x400){
		buf_size = val;
	}
	printf("Reading %d bytes\n", buf_size);
	getline(buffer, buf_size, 0xa);
	/*----snipped----*/
}　while(true);
```
つまりvalを0x400よりも大きくした場合は、それがそのまま読み取られるバッファのサイズになるようである。  
当然ながら通常の動作でvalの値を変えることはできないので、値の書き換えを可能にする脆弱性が必要になるのだが、入力を出力する時のprintfにFSBがあるので、これを使って値を書き換え、1000バイト近く入力できるようにする。  
入力制限を大幅に緩和できたのでシェルコードを実行する。  
入力できるサイズは大きくなったのでシェルコードをスタックに格納するのは可能だが、問題はどうやってRIPをシェルコードに向かせるかである。  
main関数のリターンアドレスを書き換えようにも、whileの無限ループが邪魔をするので悩んでいたが、whileで無限ループをしている場合でもコンパイラはちゃんとbool値をスタック上に確保している事に気づいたので、これを書き換えてmain関数を終了させる事にした。  
あとはNOPを沢山並べて、ある程度アドレスがズレていてもシェルコードにたどり着くようにすれば無事にシェルコードが動く。  
## 余談  
FSBで4byte書きたい時に```$hn```で分割して書くが、Pythonに関して疎いので、どうもうまくいかなかった。  
(最終的に作問者様のwrite-upを参考にしてどうにか書いた)  
あとmain関数のリターンアドレスでRIPを奪おうとすると前述の通り一手間かかるので、サブルーチンとして呼び出される関数のリターンアドレスを書き換えた方が楽だった...  